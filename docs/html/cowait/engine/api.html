<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cowait.engine.api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cowait.engine.api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import aiohttp
import asyncio
import requests
import traceback
from threading import Thread
from queue import Queue, Empty as QueueEmpty
from cowait.tasks import TaskDefinition, RemoteTask
from cowait.tasks.messages import TASK_FAIL, TASK_RETURN, TASK_LOG
from cowait.tasks.components.rpc import RpcError
from .cluster import ClusterProvider
from .errors import TaskCreationError


class ApiProvider(ClusterProvider):
    def __init__(self, args={}):
        super().__init__(&#39;api&#39;, args)
        self.url = args.get(&#39;url&#39;)
        self.token = args.get(&#39;token&#39;, None)

    def rpc(self, method: str, **kwargs) -&gt; dict:
        # todo: authentication
        url = f&#39;{self.url}/rpc/{method}&#39;
        resp = requests.post(url, json={&#39;args&#39;: kwargs}, headers={
            &#39;Cowait-Key&#39;: self.token,
        })
        if resp.status_code == 401:
            raise RuntimeError(&#39;Authentication error. Invalid token?&#39;)

        msg = resp.json()
        if resp.status_code == 200 and &#39;result&#39; in msg:
            return msg[&#39;result&#39;]
        if resp.status_code == 400 and &#39;error&#39; in msg:
            raise RpcError(msg[&#39;error&#39;])
        raise RpcError(f&#39;Request status {resp.status_code}&#39;)

    def spawn(self, taskdef: TaskDefinition) -&gt; RemoteTask:
        try:
            task = self.rpc(&#39;spawn&#39;, **taskdef.serialize())
            return RemoteTask(TaskDefinition.deserialize(task), self)
        except RpcError as e:
            raise TaskCreationError(str(e))

    def destroy(self, task_id):
        self.rpc(&#39;destroy&#39;, task_id=task_id)

    def destroy_all(self):
        self.rpc(&#39;destroy_all&#39;)

    def list_all(self):
        return self.rpc(&#39;list_tasks&#39;)

    def logs(self, task):
        ws_url = self.args.get(&#39;ws_url&#39;)
        if ws_url is None:
            print(&#39;No websocket URL set - logs not available.&#39;)
            return

        watcher = ApiLogsWatcher(task.id, ws_url)
        for log in watcher.watch():
            yield log

    def find_agent(self):
        return self.rpc(&#39;get_agent_url&#39;)


class ApiLogsWatcher(Thread):
    END = object()

    def __init__(self, task_id, ws_url):
        super().__init__()
        self.task_id = task_id
        self.ws_url = ws_url
        self.queue = Queue()

    def run(self):
        loop = asyncio.new_event_loop()
        loop.run_until_complete(self.__watch())

    def watch(self, timeout=60):
        self.start()
        while True:
            try:
                log = self.queue.get(True, timeout)
                if log is self.END:
                    break
                yield log
            except QueueEmpty:
                break

    async def __watch(self):
        try:
            session = aiohttp.ClientSession()
            ws = await session.ws_connect(self.ws_url)
            await ws.send_json({
                &#39;type&#39;: &#39;subscribe&#39;
            })
            while True:
                msg = await ws.receive()
                if msg.type == aiohttp.WSMsgType.CLOSE:
                    self.queue.put(&#39;!! Lost API connection&#39;)
                    break
                if msg.type == aiohttp.WSMsgType.ERROR:
                    self.queue.put(&#39;!! Lost API connection&#39;)
                    break

                event = msg.json()
                if &#39;id&#39; not in event or event[&#39;id&#39;] != self.task_id:
                    continue
                if event[&#39;type&#39;] == TASK_RETURN:
                    break
                if event[&#39;type&#39;] == TASK_FAIL:
                    self.queue.put(f&#39;!! {self.task_id} failed with error:&#39;)
                    self.queue.put(event[&#39;error&#39;].strip())
                    break
                if event[&#39;type&#39;] == TASK_LOG:
                    self.queue.put(event[&#39;data&#39;].strip())

        except Exception:
            traceback.print_exc()
        finally:
            await ws.close()
            await session.close()

        self.queue.put(self.END)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cowait.engine.api.ApiLogsWatcher"><code class="flex name class">
<span>class <span class="ident">ApiLogsWatcher</span></span>
<span>(</span><span>task_id, ws_url)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApiLogsWatcher(Thread):
    END = object()

    def __init__(self, task_id, ws_url):
        super().__init__()
        self.task_id = task_id
        self.ws_url = ws_url
        self.queue = Queue()

    def run(self):
        loop = asyncio.new_event_loop()
        loop.run_until_complete(self.__watch())

    def watch(self, timeout=60):
        self.start()
        while True:
            try:
                log = self.queue.get(True, timeout)
                if log is self.END:
                    break
                yield log
            except QueueEmpty:
                break

    async def __watch(self):
        try:
            session = aiohttp.ClientSession()
            ws = await session.ws_connect(self.ws_url)
            await ws.send_json({
                &#39;type&#39;: &#39;subscribe&#39;
            })
            while True:
                msg = await ws.receive()
                if msg.type == aiohttp.WSMsgType.CLOSE:
                    self.queue.put(&#39;!! Lost API connection&#39;)
                    break
                if msg.type == aiohttp.WSMsgType.ERROR:
                    self.queue.put(&#39;!! Lost API connection&#39;)
                    break

                event = msg.json()
                if &#39;id&#39; not in event or event[&#39;id&#39;] != self.task_id:
                    continue
                if event[&#39;type&#39;] == TASK_RETURN:
                    break
                if event[&#39;type&#39;] == TASK_FAIL:
                    self.queue.put(f&#39;!! {self.task_id} failed with error:&#39;)
                    self.queue.put(event[&#39;error&#39;].strip())
                    break
                if event[&#39;type&#39;] == TASK_LOG:
                    self.queue.put(event[&#39;data&#39;].strip())

        except Exception:
            traceback.print_exc()
        finally:
            await ws.close()
            await session.close()

        self.queue.put(self.END)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cowait.engine.api.ApiLogsWatcher.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cowait.engine.api.ApiLogsWatcher.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    loop = asyncio.new_event_loop()
    loop.run_until_complete(self.__watch())</code></pre>
</details>
</dd>
<dt id="cowait.engine.api.ApiLogsWatcher.watch"><code class="name flex">
<span>def <span class="ident">watch</span></span>(<span>self, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch(self, timeout=60):
    self.start()
    while True:
        try:
            log = self.queue.get(True, timeout)
            if log is self.END:
                break
            yield log
        except QueueEmpty:
            break</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cowait.engine.api.ApiProvider"><code class="flex name class">
<span>class <span class="ident">ApiProvider</span></span>
<span>(</span><span>args={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApiProvider(ClusterProvider):
    def __init__(self, args={}):
        super().__init__(&#39;api&#39;, args)
        self.url = args.get(&#39;url&#39;)
        self.token = args.get(&#39;token&#39;, None)

    def rpc(self, method: str, **kwargs) -&gt; dict:
        # todo: authentication
        url = f&#39;{self.url}/rpc/{method}&#39;
        resp = requests.post(url, json={&#39;args&#39;: kwargs}, headers={
            &#39;Cowait-Key&#39;: self.token,
        })
        if resp.status_code == 401:
            raise RuntimeError(&#39;Authentication error. Invalid token?&#39;)

        msg = resp.json()
        if resp.status_code == 200 and &#39;result&#39; in msg:
            return msg[&#39;result&#39;]
        if resp.status_code == 400 and &#39;error&#39; in msg:
            raise RpcError(msg[&#39;error&#39;])
        raise RpcError(f&#39;Request status {resp.status_code}&#39;)

    def spawn(self, taskdef: TaskDefinition) -&gt; RemoteTask:
        try:
            task = self.rpc(&#39;spawn&#39;, **taskdef.serialize())
            return RemoteTask(TaskDefinition.deserialize(task), self)
        except RpcError as e:
            raise TaskCreationError(str(e))

    def destroy(self, task_id):
        self.rpc(&#39;destroy&#39;, task_id=task_id)

    def destroy_all(self):
        self.rpc(&#39;destroy_all&#39;)

    def list_all(self):
        return self.rpc(&#39;list_tasks&#39;)

    def logs(self, task):
        ws_url = self.args.get(&#39;ws_url&#39;)
        if ws_url is None:
            print(&#39;No websocket URL set - logs not available.&#39;)
            return

        watcher = ApiLogsWatcher(task.id, ws_url)
        for log in watcher.watch():
            yield log

    def find_agent(self):
        return self.rpc(&#39;get_agent_url&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cowait.engine.cluster.ClusterProvider" href="cluster.html#cowait.engine.cluster.ClusterProvider">ClusterProvider</a></li>
<li><a title="cowait.utils.emitter.EventEmitter" href="../utils/emitter.html#cowait.utils.emitter.EventEmitter">EventEmitter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cowait.engine.api.ApiProvider.destroy_all"><code class="name flex">
<span>def <span class="ident">destroy_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_all(self):
    self.rpc(&#39;destroy_all&#39;)</code></pre>
</details>
</dd>
<dt id="cowait.engine.api.ApiProvider.find_agent"><code class="name flex">
<span>def <span class="ident">find_agent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_agent(self):
    return self.rpc(&#39;get_agent_url&#39;)</code></pre>
</details>
</dd>
<dt id="cowait.engine.api.ApiProvider.list_all"><code class="name flex">
<span>def <span class="ident">list_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_all(self):
    return self.rpc(&#39;list_tasks&#39;)</code></pre>
</details>
</dd>
<dt id="cowait.engine.api.ApiProvider.rpc"><code class="name flex">
<span>def <span class="ident">rpc</span></span>(<span>self, method: str, **kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpc(self, method: str, **kwargs) -&gt; dict:
    # todo: authentication
    url = f&#39;{self.url}/rpc/{method}&#39;
    resp = requests.post(url, json={&#39;args&#39;: kwargs}, headers={
        &#39;Cowait-Key&#39;: self.token,
    })
    if resp.status_code == 401:
        raise RuntimeError(&#39;Authentication error. Invalid token?&#39;)

    msg = resp.json()
    if resp.status_code == 200 and &#39;result&#39; in msg:
        return msg[&#39;result&#39;]
    if resp.status_code == 400 and &#39;error&#39; in msg:
        raise RpcError(msg[&#39;error&#39;])
    raise RpcError(f&#39;Request status {resp.status_code}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cowait.engine.cluster.ClusterProvider" href="cluster.html#cowait.engine.cluster.ClusterProvider">ClusterProvider</a></b></code>:
<ul class="hlist">
<li><code><a title="cowait.engine.cluster.ClusterProvider.create_env" href="cluster.html#cowait.engine.cluster.ClusterProvider.create_env">create_env</a></code></li>
<li><code><a title="cowait.engine.cluster.ClusterProvider.destroy" href="cluster.html#cowait.engine.cluster.ClusterProvider.destroy">destroy</a></code></li>
<li><code><a title="cowait.engine.cluster.ClusterProvider.logs" href="cluster.html#cowait.engine.cluster.ClusterProvider.logs">logs</a></code></li>
<li><code><a title="cowait.engine.cluster.ClusterProvider.serialize" href="cluster.html#cowait.engine.cluster.ClusterProvider.serialize">serialize</a></code></li>
<li><code><a title="cowait.engine.cluster.ClusterProvider.spawn" href="cluster.html#cowait.engine.cluster.ClusterProvider.spawn">spawn</a></code></li>
<li><code><a title="cowait.engine.cluster.ClusterProvider.wait" href="cluster.html#cowait.engine.cluster.ClusterProvider.wait">wait</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cowait.engine" href="index.html">cowait.engine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cowait.engine.api.ApiLogsWatcher" href="#cowait.engine.api.ApiLogsWatcher">ApiLogsWatcher</a></code></h4>
<ul class="">
<li><code><a title="cowait.engine.api.ApiLogsWatcher.END" href="#cowait.engine.api.ApiLogsWatcher.END">END</a></code></li>
<li><code><a title="cowait.engine.api.ApiLogsWatcher.run" href="#cowait.engine.api.ApiLogsWatcher.run">run</a></code></li>
<li><code><a title="cowait.engine.api.ApiLogsWatcher.watch" href="#cowait.engine.api.ApiLogsWatcher.watch">watch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cowait.engine.api.ApiProvider" href="#cowait.engine.api.ApiProvider">ApiProvider</a></code></h4>
<ul class="">
<li><code><a title="cowait.engine.api.ApiProvider.destroy_all" href="#cowait.engine.api.ApiProvider.destroy_all">destroy_all</a></code></li>
<li><code><a title="cowait.engine.api.ApiProvider.find_agent" href="#cowait.engine.api.ApiProvider.find_agent">find_agent</a></code></li>
<li><code><a title="cowait.engine.api.ApiProvider.list_all" href="#cowait.engine.api.ApiProvider.list_all">list_all</a></code></li>
<li><code><a title="cowait.engine.api.ApiProvider.rpc" href="#cowait.engine.api.ApiProvider.rpc">rpc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>